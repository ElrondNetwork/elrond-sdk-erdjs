QuarkChain.getEthAddressFromQkcAddress(qkcAddressHexString)
QuarkChain.injectWeb3(web3, QkcJrpcUrl)

var qkc = web3.qkc;
web3.qkc.getBalance(addressHexString [, callback])

var balance = web3.qkc.getBalance("0x653EF52aa0D9f9186f3f311193C92Ed84707519C65D931d8");
console.log(balance);  // instanceof BigNumber
console.log(balance.toString(10));  // '1000000000000'
console.log(balance.toNumber());  // 1000000000000

web3.qkc.contract(abiArray)

var MyContract = web3.qkc.contract(abiArray);

// instantiate by address
var contractInstance = MyContract.at(address);

// deploy new contract
var contractInstance = MyContract.new([constructorParam1] [, constructorParam2], {data: '0x12345...', from: myAccount, gas: 1000000, gasPrice: 1000000000, fromFullShardKey: fromFullShardKey, toFullShardKey: toFullShardKey});

// Get the data to deploy the contract manually
var contractData = MyContract.new.getData([constructorParam1] [, constructorParam2], {data: '0x12345...'});
// contractData = '0x12345643213456000000000023434234'


let source = fs.readFileSync('nameContract.sol', 'utf8');
let compiledContract = solc.compile(source, 1);
let abi = compiledContract.contracts['nameContract'].interface;
let bytecode = compiledContract.contracts['nameContract'].bytecode;
let MyContract = web3.eth.contract(JSON.parse(abi));

var myContractReturned = MyContract.new(param1, param2, {
   data: bytecode,
   gas: 1000000}, function(err, myContract){
    if(!err) {
       // NOTE: The callback will fire twice!
       // Once the contract has the transactionId property set and once its deployed on an address.

       // e.g. check tx hash on the first call (transaction send)
       if(!myContract.address) {
           console.log(myContract.transactionId); // The id of the transaction, which deploys the contract

       // check address on the second call (contract deployed)
       } else {
           console.log(myContract.address); // the contract address
       }

       // Note that the returned "myContractReturned" === "myContract",
       // so the returned "myContractReturned" object will also get the address set.
    }
  });


// contract abi
var abi = [{
     name: 'myConstantMethod',
     type: 'function',
     constant: true,
     inputs: [{ name: 'a', type: 'string' }],
     outputs: [{name: 'd', type: 'string' }]
}, {
     name: 'myStateChangingMethod',
     type: 'function',
     constant: false,
     inputs: [{ name: 'a', type: 'string' }, { name: 'b', type: 'int' }],
     outputs: []
}, {
     name: 'myEvent',
     type: 'event',
     inputs: [{name: 'a', type: 'int', indexed: true},{name: 'b', type: 'bool', indexed: false}]
}];

// creation of contract object
var MyContract = web3.qkc.contract(abi);

// initiate contract for an address
var myContractInstance = MyContract.at('0xD08305d78C6DF48c312c46125B919A79B312739765D931d8');

// call constant function
var result = myContractInstance.myConstantMethod('myParam');
console.log(result) // '0x25434534534'

// send a transaction to a function
myContractInstance.myStateChangingMethod('someParam1', 23, {value: 200, gas: 2000});

// short hand style
web3.qkc.contract(abi).at(address).myAwesomeMethod(...);